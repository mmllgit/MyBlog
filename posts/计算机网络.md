---
title: 2022/9/12
excerpt: http协议
image: head.jpg
date: "2022-9-12"
isFeatured: false
---

### 网络分层模型

+ OSI七层模型（理论模型）
  + 物理层
  + 数据链路层
  + 网络层
  + 传输层
  + 会话层
  + 表示层
  + 应用层
+ TCP/IP四层模型（基于OSI建立的实际实现）
  + 网络接口层（硬件协议）
  + 网络层（ip）
  + 传输层（tcp，udp）
  + 应用层（http）

### TCP三次握手和四次挥手

### 三次握手原因

+ 检测双发收发都无问题
+ 第一次保证客户端发送能力没问题
+ 第二保证服务端接受和发送能力没问题
+ 第三次保证客户端的接收能力没问题

### 四次挥手原因

+ 因为在第二次时，被动关闭方可能还有一些数据还在发送中，所以会在发送完毕后发送一个fin请求

### HTTP协议（超文本传输协议）

+ http0.9：只有get请求，服务端直传html格式字符串，服务端响应完久关闭连接
+ http1.0：可以发送任何格式内容，包括文字图像视频二进制等，也丰富了请求方式，get，post，head请求和响应格式，但每个tcp连接只能发送一个请求，而新建tcp连接的成本很高，导致性能差
+ http1.1：引入持久连接，tcp默认不关闭，可被多个请求复用
+ http2.0：采用二进制格式而非文本格式，解析高效，数据更紧凑，错误更少，服务端可以将响应主动推送到客户端
  + 特点：必须使用https协议，使用多路复用，请求头header压缩

### HTTP报文格式

+ http请求行：包括请求方式，请求url，协议版本号
+ http请求头：key：value键值对，保存一些信息
+ http请求体，post等请求的参数放在请求体中

### SSL握手

+ 确定双方如何进行加解密
+ 重点在于在不安全的网络中进行安全的密钥交换
+ 握手阶段使用非对此加密，非堆成加密队性能损耗较大，使用对称加密进行正式的传输数据

#### 四次握手

1. 客户端发送一个随机值以及需要的协议和加密方式
2. 服务端收到随机值，自己也产生一个随机值，并根据客户端的协议和加密方式使用对应方式，并发送自己的数字证书
3. 客户端收到服务端的证书并验证是否有效，验证通过生成随机值，使用证书的公钥去加密随机值
4. 服务端收到加密的随机值，使用私钥进行解密，这时两端都拥有三个随机值，可通过三个随机按约定方式生成密钥，通信时可使用该密钥进行加解密

### 从URL到浏览器渲染

#### 输入地址时

+ 当输入地址时，浏览器已经在智能匹配url了，它会从历史记录或则标签页中找到已经输入字符串对应的url了，给你提示，让你不全，你还没按下回车键时，浏览器已经开始DNS预取技术开始解析域名

#### DNS域名解析

+ 首先查找自己的DNS缓存
+ 如果未找到，则在系统缓存中查找，包括host文件中查找对应的映射
+ 如果还未查找到会到路由器的DNS缓存中查找
+ 如果还未找到则操作系统会将域名发送到本地域名服务器，本地域名服务器查找自己的DNS缓存，若还未成功则采用迭代查询方式，本地域名服务器先查询根域名服务器后返回，接着查询顶级域名服务后返回，在然后查询权威域名服务器返回本地域名服务器，最后返回给客户端，自己也将DNS缓存起来
+ 客户端将iP返回给浏览器，并缓存，然后找到了域名对应的IP地址。

### 建立TCP连接

#### 三次握手

1. 客户端向服务端发送请求，验证服务端的发送能力
2. 服务端向客户端发送请求，验证了服务端的接受和发送能力
3. 服务端向客户端发送请求，验证了客户端的接受能力

#### SSL握手过程

1. 客户端向服务端发送一个随机数，并表明需要的加密方式
2. 服务端收到客户端的随机数，自己也生成一个随机，并按找客户端的加密方式做相应处理，然后服务端发送随机数和数字证书
3. 客户端收到数字证书，并在次生成一个随机数，并用服务端的公钥加密随机数发送给服务端
4. 服务端使用私钥解密随机数，这时双方都有三个随机数，在按照之前约定的方式生成密钥，在后续的通信中使用对称加密的方式

### 发起HTTP请求

1. 建立tcp连接过后，浏览器利用http/https协议发送请求，服务器收到请求后，会解析请求头，如果头部有缓存相关的信息，则验证缓存是否有效，有效则返回状态码304，无效则重新返回资源，状态码未200

### 关闭TCP连接

#### TCP四次挥手

+ 第一次挥手主动关闭放发送FIN请求
+ 第二次被动关闭方收到主动关闭方的请求，可能有未发送完毕的数据，先发送了确认码，
+ 第三次被动关闭方接着在数据发送完后，给主动关闭放发送FIN请求
+ 第四次主动关闭方收到过后给被动关闭方发送last_close请求，等待2msl事件后关闭，被动关闭方收到主动关闭方的请求后立即关闭。

### 浏览器渲染

#### 构建DOM树

+ 首先将接收到的html二进制数据解码成html字符串
+ 然后将解析的html字符串转成结果清晰的标签
+ 然后将tokens转换为节点，每个节点添加特定的属性，通过指针确定父子元素等
+ 最后构建DOM树，建立起每个节点的父子关系

#### 样式计算

+ 将css样式表转化为DOM节点的样式，会将所有值转化为渲染引擎容易理解、标准化的计算值，完成属性的标准化

#### 页面布局

+ 排除一些功能化标签、非视觉类的标签，排序display为none的节点，计算元素的位置信息，确定元素的位置，构建一颗只包含可见元素的布局树

#### 生成分层树

+ 为了实现一写复杂效果，如3d效果，页面滚动，z-index的使用等，渲染引擎会为特定的节点生成专用的图层，生成图层树

#### 栅格化

+ 合成线程会按照视口图块来优先生成位图

#### 显示

+ 最后，合成线程发送绘制图块命令给浏览器进程。浏览器进程根据指令生成页面，并显示到显示器上，渲染过程完成

### HTTP状态码

+ 200 成功
+ 304 资源未改变，使用本地缓存
+ 400 客户端请求语法错误
+ 404 未找到资源
+ 500 服务器错误

### 强缓存

+ 强缓存其实就是存储在本地的资源，如果命中缓存，则直接使用缓存资源，如果没有则进行下一步

### 强缓存方式

+ expire通过expire设置失效时间，与本地系统的时间比，如果用户修改本地时间就可能导致缓存失效，这是一个缺点，所以诞生了max-age
+ cache-contorl：max-age的优先级比expire优先级高，设置多少秒缓存失效

### 查找协商缓存

+ 协商缓存就是客户端向服务端发送请求，如果存在协商换成则返回304并使用缓存

### 协商缓存和强缓存的区别

+ 协商缓存每次都要发起请求，服务器判断资源是否更新，没有更新返回304，更新了则直接返回资源，与cache-control：no-cache搭配使用
+ 强缓存不需要每次都发起请求，通过expire和max-age判断缓存是否失效，不失效则直接使用

### 协商缓存方式

+ 服务端给响应头加上last-modified字段，再次请求时浏览器会把last-modified的值加到if-modified-since上，服务端根据此字段判断资源是否更新
  + 缺点：粒度为秒，在1秒内修改资源，缓存还是不会更新
  + 我只修改资源，但不改变内容，缓存还是会失效
+ ETAG优先级高，是内容签名，是内容生成的hash值，当初次请求时，服务端给客户端加上etag，再次请求时，将etag加载ifnonematch上，服务端再根据此字段判断是否更新

